{
  
    
        "post0": {
            "title": "The history of COVID-19 in San Diego County",
            "content": "Table of Contents - click on a link to go there . Software: (don&#39;t care how it&#39;s made? skip ahead!) . Code to grab data from San Diego County website | Code to fit exponential models to the data | . Analyses: . The history of COVID-19 in San Diego | Fraction of cases which result in hospitalization or worse | How many new COVID cases there are today | Doubling times &amp; flattening the curve | Social distancing is what flattened the curve | Introduction . A small (yet worryingly large) group of people are currently protesting the things that are keeping us safe: stay at home orders, and closure orders for non-essential business and recreation. Some of these people are informed and honest, they say &quot;more people will die, but freedom or the economy is more important.&quot; . Some of these people don&#39;t understand fully what&#39;s going on. With this post I&#39;m trying to reach those people. So if you say things like &quot;COVID-19 is not so bad, look how few people have died, we need to end these restrictions&quot; or &quot;We already have herd immunity because it was here for months and months, so we don&#39;t need these restrictions&quot;, then please read and feel free to ask questions. . I&#39;m trying to show that social distancing, the stay at home orders, and school/park/beach closures have saved many lives. Without it San Diego hospitals would be in crisis with thousands more sick and hundreds more dead than we have today. . Please read the analyses below to understand why. . Code to scrape the county website . #collapse import pandas as pd from dateparser.search import search_dates import seaborn as sns import glob from tabula import read_pdf import numpy as np sns.set_style(&#39;darkgrid&#39;) colors = sns.color_palette() import matplotlib.pyplot as plt dataf = &#39;Data/SDcountySituation-{}.csv&#39; locf = &#39;Data/SDcountyLocations-{}.csv&#39; zipf = &#39;Data/SDcountyZipcodes-{}.csv&#39; tab_hist = {} . . #collapse # This first part was a one time only thing, no longer necessary: # I used the wayback machine to collect the county data for the # dates before I began this project, starting with first day over 100 cases # which was March 19th &#39;&#39;&#39;get_historical_data = [ &#39;https://web.archive.org/web/20200320184055/https://www.sandiegocounty.gov/content/sdc/hhsa/programs/phs/community_epidemiology/dc/2019-nCoV/status.html&#39;, &#39;https://web.archive.org/web/20200321141257/https://www.sandiegocounty.gov/content/sdc/hhsa/programs/phs/community_epidemiology/dc/2019-nCoV/status.html&#39;, &#39;https://web.archive.org/web/20200322080211/https://www.sandiegocounty.gov/content/sdc/hhsa/programs/phs/community_epidemiology/dc/2019-nCoV/status.html&#39;, &#39;https://web.archive.org/web/20200323094801/https://www.sandiegocounty.gov/content/sdc/hhsa/programs/phs/community_epidemiology/dc/2019-nCoV/status.html&#39;, &#39;https://web.archive.org/web/20200324003021/https://www.sandiegocounty.gov/content/sdc/hhsa/programs/phs/community_epidemiology/dc/2019-nCoV/status.html&#39; ] for link in get_historical_data: tab = pd.read_html(link) #comes down as a list of each column seperately, with the header the same in each column-table table = tab[2].drop(0) # setup header and index cs = table.iloc[0,:].to_list() cs[0] = &#39;index&#39; table.columns = cs table = table.drop(1).set_index(&#39;index&#39;) # get todays date from that header we threw away on each column dt = search_dates(tab[2].iloc[0,0])[-1][1] today = dt.strftime(&#39;%Y-%m-%d&#39;) # theres some variability in nomenclature to deal with from day to day idx = table.index.to_series() idx[ &#39;Hospitalized&#39; == idx ] = &#39;Hospitalizations&#39; table.index = idx if not &#39;Intensive Care&#39; in idx: table.loc[&#39;Intensive Care&#39;,:] = 0 print(today) # record todays data for posterity table.to_csv(dataf.format(today)) tab_hist[today] = table &#39;&#39;&#39;; # That old data, and every day since, is now in the repo # From now on we can just load the data that&#39;s already in the repo files = glob.glob(&#39;Data/SDcountySituation*.csv&#39;) # gets all .csv filenames in directory for afile in files: dt = afile.split(&#39;/&#39;)[1][18:28] print(dt) tab_hist[dt] = pd.read_csv(afile,index_col=0,header=0) . . 2020-04-09 2020-03-28 2020-03-29 2020-04-08 2020-03-22 2020-04-03 2020-04-02 2020-04-16 2020-03-23 2020-03-21 2020-04-14 2020-04-15 2020-04-01 2020-03-20 2020-04-05 2020-04-11 2020-03-30 2020-03-24 2020-03-25 2020-03-31 2020-03-19 2020-04-10 2020-04-04 2020-04-12 2020-04-06 2020-03-27 2020-03-26 2020-04-07 2020-04-13 . # Run me every day! Website updates once a day at around 4pm tab = pd.read_html(&#39;https://www.sandiegocounty.gov/content/sdc/hhsa/programs/phs/community_epidemiology/dc/2019-nCoV/status.html&#39;) #comes down as a list of each column seperately, with the header the same in each column-table tabs = [ x.drop(0) for x in tab] table = pd.concat(tabs) # setup header and index cs = table.iloc[0,:].to_list() cs[0] = &#39;index&#39; table.columns = cs table = table.drop(1).set_index(&#39;index&#39;) # get todays date from that header we threw away on each column # great, they&#39;ve updated the format again and now it says #&quot;updated Date X with data through Date X-1&quot; # it&#39;s like they&#39;re trying to make it harder for me by changing something every day! # need to go back to Date X format for consistency with previous data # OLD: dt = search_dates(tab[0][0][0])[-1][1] dt = search_dates(tab[0][0][0])[-2][1] today = dt.strftime(&#39;%Y-%m-%d&#39;) . # Sstarting 26 March the Total and non-county residents columns disappeared # and everythign is under San Diego County Residents, even though I believe that is actually the Total column # if i&#39;m wrong this generates a discontinuity of 20 non-resident cases, making the growth from 25 - 26 March look # smaller than it is, it will lead to an underestimate of the exponential coefficient # Update: I was wrong. There is an underestimate of the early doubling time built into the data. Now after a few days of seeing county briefs I understand that thye changed how they count... people&#39;s registered address with DMV is used to count the numbers... not where they actually lived or where they visited the hospital. # and each jurisdiction is now only counting its residents (in this sense of the word), not the people in its hospitals table.columns=[&#39;Total&#39;] # record todays data for posterity table.to_csv(dataf.format(today)) tab_hist[today] = table print(today) table . 2020-04-20 . Total . index . Total Positives | 2325 | . Age Groups | NaN | . 0-9 years | 17 | . 10-19 years | 43 | . 20-29 years | 354 | . 30-39 years | 431 | . 40-49 years | 398 | . 50-59 years | 438 | . 60-69 years | 318 | . 70-79 years | 178 | . 80+ years | 144 | . Age Unknown | 4 | . Gender | NaN | . Female | 1149 | . Male | 1172 | . Unknown | 4 | . Hospitalizations | 562 | . Intensive Care | 189 | . Deaths | 72 | . cases = pd.Series({key:int(value.loc[&#39;Total Positives&#39;,&#39;Total&#39;]) for key,value in tab_hist.items()}).sort_index() hospitalizations = pd.Series({key:int(value.loc[&#39;Hospitalizations&#39;,&#39;Total&#39;]) for key,value in tab_hist.items()}).sort_index() icu = pd.Series({key:int(value.loc[&#39;Intensive Care&#39;,&#39;Total&#39;]) for key,value in tab_hist.items()}).sort_index() deaths = pd.Series({key:int(value.loc[&#39;Deaths&#39;,&#39;Total&#39;]) for key,value in tab_hist.items()}).sort_index() totals = pd.DataFrame( {&#39;Confirmed cases&#39;:cases, &#39;Hospitalizations&#39;:hospitalizations, &#39;ICU patients&#39;:icu, &#39;Deaths&#39;:deaths}) . Code to fit exponential models to the COVID data . The classic model of disease outbreaks is an exponential function. One person infects two. Two infect four. Four infect eight. And in ten easy steps you get to thousands of people, in twenty doubling steps its millions of people infected. . Below is how the suasage is made in the models . import numpy as np from scipy.optimize import curve_fit from scipy.stats.distributions import t def exfunc(x, a, b): &#39;&#39;&#39;This is the form of an exponential function which we will fit to pandemic data&#39;&#39;&#39; return a * np.exp(b * x) def estimate_doubling_time(data): &#39;&#39;&#39; Given some data, fits parameters for an exponential function defined in exfunc() and returns the resulting doubling time along with other useful info Inputs: data - the data points to be fit, e.g. a 5 day window of COVID hospitalization totals Outputs: doubling time - maximum likelihood estimate of exponential doubling time ci95 - 95% confidence interval on that estimate (only 5% chance that the true value is outside doubling_time +/- ci95) pest - maximum likelihood estimate of the exponential parameters a,b defined in exfunc() pcov - covariance matrix of the exponential parameters a,b defined in exfunc() &#39;&#39;&#39; # use Levenberg-Marquardt algorithm to solve for a minimum in the # nonlinear least squares error function (find the best parameters to fit the data) pest, pcov = curve_fit(exfunc, range(len(data)), data) # the above just found the parameters a,b that best fit a*exp(b*x) to the data # the doubling time of an exponential function like the above is just: log(2)/b doubling_time = np.log(2)/pest[1] # next we are going to put a confidence interval on our doubling time alpha = 0.05 # 95% confidence interval = 100*(1-alpha) n = len(data) # number of data points p = len(pest) # number of parameters dof = max(0, n - p) # number of degrees of freedom # Students-t value for the dof and confidence level tval = t.ppf(1.0-alpha/2., dof) # curve_fit() gave a covariance matrix on the fit, turn that into standard deviation of a,b sigmas = np.power( np.diag(pcov), 0.5) # magnitude of the confidence interval is simply Students-t * std deviation of doubling time # so we have to translate from std deviation of parameter b to std deviation of doubling time ci95 = (np.log(2)/(pest[1]-sigmas[1]) - doubling_time)*tval # output results of this fit print(&#39;t:{:4.3f} p0:[{:4.3f}+/-{:4.3f}] p1:[{:4.3f}+/-{:4.3f}] dtime:{:4.3f}+/-{:4.3f}&#39;.format( tval, pest[0], sigmas[0], pest[1], sigmas[1], doubling_time, ci95)) return(doubling_time, ci95, pest, pcov) def days_to_value(pest, y): &#39;&#39;&#39; pest = [a, b] y = a * exp( b * x ) ln(y) - ln(a) = b * x x = ( ln(y) - ln(a) ) / b &#39;&#39;&#39; return (np.log(y) - np.log(pest[0]))/pest[1] . . The history of COVID-19 infections and hospitalizations in San Diego . totals.plot(subplots=True,sharex=True,figsize=(8,10),marker=&#39;.&#39;) plt.suptitle(&#39;San Diego County COVID-19 history&#39;) plt.savefig(&#39;Plots/chistory.png&#39;,dpi=300); . . Fraction of confirmed COVID-19 cases that get bad, really bad, and dead . frac = totals[[&#39;Hospitalizations&#39;,&#39;ICU patients&#39;,&#39;Deaths&#39;]] frac = frac.apply(lambda x: x/totals[&#39;Confirmed cases&#39;]) frac.plot(subplots=True,sharex=True,figsize=(8,10),marker=&#39;.&#39;,color=colors[1:]); plt.suptitle(&#39;To date, fraction of total confirmed COVID-19 cases resulting in ...&#39;); . frac = totals[[&#39;ICU patients&#39;,&#39;Deaths&#39;]] frac = frac.apply(lambda x: x/totals[&#39;Hospitalizations&#39;]) frac.plot(subplots=True,sharex=True,figsize=(8,10),marker=&#39;.&#39;,color=colors[1:]); plt.suptitle(&#39;To date, fraction of COVID-19 hospitalizations resulting in ...&#39;); . . Daily COVID increases in San Diego county . These nubers are the most raw way you can see the curve is flattening. Under normal steep exponential growth you would see daily numbers that are always getting bigger. These are starying the same right now, and maybe falling! . # Obviously the first date (20th or 21st depending on metric) is ignorable because it contains all previous days # Also I&#39;m pretty sure the -5 hospitalizations on 23rd indicates that some data reclassification happened that day, not that some people were cured and walked out of hospital. totals.diff().rename(lambda x: &#39;Todays new &#39;+x, axis=&#39;columns&#39;).plot(subplots=True,sharex=True,figsize=(8,10),marker=&#39;.&#39;); plt.suptitle(&#39;San Diego County COVID daily increases: nIncreases would be growing exponentially if the curve was not flattening&#39;) plt.savefig(&#39;Plots/cdeltas.png&#39;,dpi=300); . . Is the curve flattening? . Doubling time is the # of days for the number of cases/hospitalizations to double. Small numbers are bad, they mean a steep curve. Big numbers are good, they mean the exponential is flattening. . I&#39;m using a sliding 7 day window to see how the doubling time is changing from day to day. I&#39;m using t-statistic estimated 95% confidence intervals on the exponential fit to estimate a range of plausibitlty in the estimates. When you see that April 10th has no overlap with the value on March 27th, you can be very sure that the difference is real, the curve is flattening, and it isn&#39;t just random noise causing this. . TL;DR To see if the outbreak is slowing, we want the doubling time to get quite a bit bigger. And we are seeing that, bigtime!!! . # The 27th is the first date I&#39;d trust since that elimantes the big delta of # the 1st data point on I collected on March 20th. start_calc = &#39;2020-03-27&#39; ex = [] er = [] ix = [] # calc doubling time in a sliding window backwards 1 week for each day for day in cases[start_calc:].index: todate = day fromdate = (pd.Timestamp(day)-pd.Timedelta(&#39;6 days&#39;)).isoformat().split(&#39;T&#39;)[0] doubling_time, ci95, case_p_est, case_p_cov = estimate_doubling_time(cases[fromdate:todate]) ex.append( doubling_time ) er.append( ci95 ) ix.append( day[-4:] ) plt.errorbar( ix, ex, yerr=er, fmt=&#39;.&#39;, markersize=15) plt.title(&#39;Time for confirmed COVID-19 cases to double in San Diego County ncalc &#39;d on 1 week sliding window before date: nSharp increase since April 3 shows we are flattening the curve&#39;) plt.ylabel(&#39;Days to double (expected +/- 95%CI)&#39;) plt.xlabel(&#39;Date&#39;) plt.ylim([.5, 25.5]) plt.xticks(rotation=-60) plt.savefig(&#39;Plots/casedoubling.png&#39;,dpi=300); . t:2.571 p0:[163.419+/-6.718] p1:[0.152+/-0.009] dtime:4.558+/-0.748 t:2.571 p0:[189.203+/-7.006] p1:[0.156+/-0.008] dtime:4.449+/-0.634 t:2.571 p0:[223.507+/-9.631] p1:[0.147+/-0.010] dtime:4.725+/-0.853 t:2.571 p0:[260.191+/-10.238] p1:[0.143+/-0.009] dtime:4.857+/-0.823 t:2.571 p0:[301.414+/-10.366] p1:[0.145+/-0.008] dtime:4.779+/-0.688 t:2.571 p0:[346.973+/-10.666] p1:[0.148+/-0.007] dtime:4.694+/-0.588 t:2.571 p0:[405.719+/-10.605] p1:[0.145+/-0.006] dtime:4.781+/-0.517 t:2.571 p0:[466.635+/-10.257] p1:[0.146+/-0.005] dtime:4.764+/-0.428 t:2.571 p0:[546.515+/-16.961] p1:[0.137+/-0.007] dtime:5.046+/-0.697 t:2.571 p0:[653.222+/-21.106] p1:[0.123+/-0.007] dtime:5.656+/-0.938 t:2.571 p0:[779.091+/-23.922] p1:[0.104+/-0.007] dtime:6.686+/-1.288 t:2.571 p0:[907.715+/-30.874] p1:[0.085+/-0.008] dtime:8.137+/-2.231 t:2.571 p0:[1032.789+/-29.127] p1:[0.070+/-0.007] dtime:9.918+/-2.820 t:2.571 p0:[1146.901+/-17.591] p1:[0.059+/-0.004] dtime:11.659+/-2.073 t:2.571 p0:[1241.277+/-13.384] p1:[0.053+/-0.003] dtime:13.073+/-1.825 t:2.571 p0:[1330.884+/-7.353] p1:[0.048+/-0.001] dtime:14.552+/-1.142 t:2.571 p0:[1407.610+/-12.532] p1:[0.044+/-0.002] dtime:15.884+/-2.260 t:2.571 p0:[1483.265+/-17.747] p1:[0.039+/-0.003] dtime:17.647+/-3.885 t:2.571 p0:[1561.170+/-13.940] p1:[0.036+/-0.002] dtime:19.436+/-3.486 t:2.571 p0:[1632.103+/-8.743] p1:[0.034+/-0.001] dtime:20.476+/-2.270 t:2.571 p0:[1687.072+/-9.590] p1:[0.035+/-0.001] dtime:20.015+/-2.303 t:2.571 p0:[1742.070+/-9.358] p1:[0.035+/-0.001] dtime:19.528+/-2.061 t:2.571 p0:[1799.132+/-8.595] p1:[0.036+/-0.001] dtime:19.444+/-1.808 t:2.571 p0:[1869.229+/-12.334] p1:[0.034+/-0.002] dtime:20.492+/-2.829 t:2.571 p0:[1952.489+/-11.098] p1:[0.030+/-0.001] dtime:22.914+/-3.061 . # hospitalizations has a weird negative change on the 23rd, due (I think) to them removing # non-SD county residents from the data who were in hospital here # this negative prbably results in us underestimating the doubling time on 3/27 start_calc = &#39;2020-03-27&#39; ex = [] er = [] ix = [] # calc doubling time in a sliding window backwards 1 week for each day for day in hospitalizations[start_calc:].index: todate = day fromdate = (pd.Timestamp(day)-pd.Timedelta(&#39;6 days&#39;)).isoformat().split(&#39;T&#39;)[0] doubling_time, ci95, hosp_p_est, hosp_p_cov = estimate_doubling_time(hospitalizations[fromdate:todate]) ex.append( doubling_time ) er.append( ci95 ) ix.append( day[-4:] ) plt.errorbar( ix, ex, yerr=er, fmt=&#39;.&#39;, markersize=15) plt.title(&#39;Time for COVID-19 hospitalizations to double in San Diego County ncalc &#39;d on 1 week sliding window before date: nSharp increase since April 3 shows we are flattening the curve&#39;) plt.ylabel(&#39;Days to double (expected +/- 95%CI)&#39;) plt.xlabel(&#39;Date&#39;) plt.ylim([.5, 25.5]) plt.xticks(rotation=-60) plt.savefig(&#39;Plots/hospitaldoubling.png&#39;,dpi=300); . t:2.571 p0:[30.144+/-2.402] p1:[0.168+/-0.017] dtime:4.130+/-1.228 t:2.571 p0:[34.786+/-2.189] p1:[0.171+/-0.014] dtime:4.042+/-0.901 t:2.571 p0:[41.040+/-2.292] p1:[0.165+/-0.012] dtime:4.191+/-0.860 t:2.571 p0:[51.606+/-2.635] p1:[0.144+/-0.011] dtime:4.827+/-1.075 t:2.571 p0:[62.549+/-1.798] p1:[0.130+/-0.007] dtime:5.321+/-0.723 t:2.571 p0:[72.080+/-1.579] p1:[0.129+/-0.005] dtime:5.373+/-0.556 t:2.571 p0:[82.532+/-1.477] p1:[0.129+/-0.004] dtime:5.369+/-0.450 t:2.571 p0:[91.797+/-1.558] p1:[0.137+/-0.004] dtime:5.064+/-0.375 t:2.571 p0:[105.753+/-2.339] p1:[0.132+/-0.005] dtime:5.254+/-0.535 t:2.571 p0:[123.446+/-3.726] p1:[0.122+/-0.007] dtime:5.698+/-0.887 t:2.571 p0:[144.726+/-4.513] p1:[0.108+/-0.007] dtime:6.427+/-1.200 t:2.571 p0:[167.693+/-4.399] p1:[0.094+/-0.006] dtime:7.349+/-1.341 t:2.571 p0:[189.631+/-3.050] p1:[0.086+/-0.004] dtime:8.066+/-0.980 t:2.571 p0:[209.900+/-1.383] p1:[0.083+/-0.002] dtime:8.366+/-0.422 t:2.571 p0:[227.727+/-1.357] p1:[0.083+/-0.001] dtime:8.353+/-0.380 t:2.571 p0:[249.251+/-2.480] p1:[0.079+/-0.002] dtime:8.744+/-0.708 t:2.571 p0:[273.234+/-4.357] p1:[0.073+/-0.004] dtime:9.479+/-1.379 t:2.571 p0:[301.946+/-7.719] p1:[0.061+/-0.006] dtime:11.330+/-3.399 t:2.571 p0:[329.195+/-6.330] p1:[0.053+/-0.005] dtime:13.007+/-3.362 t:2.571 p0:[351.665+/-5.250] p1:[0.052+/-0.004] dtime:13.382+/-2.715 t:2.571 p0:[371.809+/-5.125] p1:[0.051+/-0.004] dtime:13.560+/-2.563 t:2.571 p0:[391.650+/-5.370] p1:[0.050+/-0.003] dtime:13.896+/-2.687 t:2.571 p0:[412.831+/-6.593] p1:[0.047+/-0.004] dtime:14.777+/-3.624 t:2.571 p0:[435.308+/-7.993] p1:[0.043+/-0.005] dtime:16.165+/-5.148 t:2.571 p0:[466.366+/-6.671] p1:[0.034+/-0.004] dtime:20.567+/-6.597 . # ICU patients start_calc = &#39;2020-03-27&#39; ex = [] er = [] ix = [] # calc doubling time in a sliding window backwards 1 week for each day for day in hospitalizations[start_calc:].index: todate = day fromdate = (pd.Timestamp(day)-pd.Timedelta(&#39;6 days&#39;)).isoformat().split(&#39;T&#39;)[0] doubling_time, ci95, icu_p_est, icu_p_cov = estimate_doubling_time(icu[fromdate:todate]) ex.append( doubling_time ) er.append( ci95 ) ix.append( day[-4:] ) plt.errorbar( ix, ex, yerr=er, fmt=&#39;.&#39;, markersize=15) plt.title(&#39;Time for COVID-19 ICU patients to double in San Diego County ncalc &#39;d on 1 week sliding window before date: nSharp increase since April 3 shows we are flattening the curve&#39;) plt.ylabel(&#39;Days to double (expected +/- 95%CI)&#39;) plt.xlabel(&#39;Date&#39;) plt.ylim([.5, 25.5]) plt.xticks(rotation=-60) plt.savefig(&#39;Plots/icudoubling.png&#39;,dpi=300); . t:2.571 p0:[12.762+/-0.676] p1:[0.183+/-0.011] dtime:3.794+/-0.649 t:2.571 p0:[15.864+/-0.896] p1:[0.168+/-0.012] dtime:4.128+/-0.841 t:2.571 p0:[19.711+/-1.073] p1:[0.150+/-0.012] dtime:4.618+/-1.041 t:2.571 p0:[24.311+/-1.220] p1:[0.129+/-0.011] dtime:5.360+/-1.336 t:2.571 p0:[29.514+/-0.792] p1:[0.110+/-0.006] dtime:6.316+/-0.983 t:2.571 p0:[32.896+/-0.821] p1:[0.112+/-0.006] dtime:6.204+/-0.875 t:2.571 p0:[37.831+/-0.571] p1:[0.103+/-0.004] dtime:6.700+/-0.613 t:2.571 p0:[40.668+/-1.284] p1:[0.117+/-0.007] dtime:5.916+/-1.011 t:2.571 p0:[45.817+/-1.397] p1:[0.114+/-0.007] dtime:6.092+/-1.039 t:2.571 p0:[52.186+/-1.969] p1:[0.104+/-0.009] dtime:6.654+/-1.593 t:2.571 p0:[59.409+/-2.199] p1:[0.094+/-0.009] dtime:7.369+/-1.961 t:2.571 p0:[67.615+/-2.045] p1:[0.082+/-0.007] dtime:8.419+/-2.116 t:2.571 p0:[74.221+/-1.922] p1:[0.081+/-0.006] dtime:8.565+/-1.855 t:2.571 p0:[82.068+/-1.400] p1:[0.077+/-0.004] dtime:8.978+/-1.316 t:2.571 p0:[87.556+/-1.050] p1:[0.080+/-0.003] dtime:8.713+/-0.853 t:2.571 p0:[95.715+/-2.020] p1:[0.073+/-0.005] dtime:9.487+/-1.863 t:2.571 p0:[105.024+/-2.338] p1:[0.065+/-0.006] dtime:10.657+/-2.548 t:2.571 p0:[115.086+/-2.625] p1:[0.055+/-0.006] dtime:12.660+/-3.828 t:2.571 p0:[125.267+/-1.421] p1:[0.046+/-0.003] dtime:15.156+/-2.643 t:2.571 p0:[132.632+/-0.839] p1:[0.043+/-0.002] dtime:16.028+/-1.612 t:2.571 p0:[138.539+/-0.884] p1:[0.044+/-0.002] dtime:15.848+/-1.587 t:2.571 p0:[145.286+/-1.757] p1:[0.040+/-0.003] dtime:17.247+/-3.740 t:2.571 p0:[152.843+/-1.964] p1:[0.036+/-0.003] dtime:19.396+/-5.152 t:2.571 p0:[160.273+/-2.546] p1:[0.030+/-0.004] dtime:23.054+/-9.562 t:2.571 p0:[168.902+/-2.399] p1:[0.022+/-0.004] dtime:31.950+/-17.377 . # Deaths start_calc = &#39;2020-03-27&#39; ex = [] er = [] ix = [] # calc doubling time in a sliding window backwards 1 week for each day for day in hospitalizations[start_calc:].index: todate = day fromdate = (pd.Timestamp(day)-pd.Timedelta(&#39;6 days&#39;)).isoformat().split(&#39;T&#39;)[0] doubling_time, ci95, deaths_est, deaths_p_cov = estimate_doubling_time(deaths[fromdate:todate]) ex.append( doubling_time ) er.append( ci95 ) ix.append( day[-4:] ) plt.errorbar( ix, ex, yerr=er, fmt=&#39;.&#39;, markersize=15) plt.title(&#39;Time for COVID-19 deaths to double in San Diego County ncalc &#39;d on 1 week sliding window before date: nSharp increase since April 3 shows we are flattening the curve&#39;) plt.ylabel(&#39;Days to double (expected +/- 95%CI)&#39;) plt.xlabel(&#39;Date&#39;) plt.ylim([.5, 25.5]) plt.xticks(rotation=-60) plt.savefig(&#39;Plots/hospitaldoubling.png&#39;,dpi=300); . t:2.571 p0:[0.466+/-0.122] p1:[0.390+/-0.049] dtime:1.775+/-0.661 t:2.571 p0:[0.752+/-0.104] p1:[0.371+/-0.026] dtime:1.866+/-0.366 t:2.571 p0:[1.436+/-0.319] p1:[0.282+/-0.044] dtime:2.459+/-1.173 t:2.571 p0:[2.405+/-0.536] p1:[0.201+/-0.047] dtime:3.448+/-2.715 t:2.571 p0:[3.150+/-0.555] p1:[0.179+/-0.038] dtime:3.863+/-2.672 t:2.571 p0:[3.421+/-0.705] p1:[0.229+/-0.043] dtime:3.030+/-1.780 t:2.571 p0:[4.564+/-0.727] p1:[0.211+/-0.033] dtime:3.281+/-1.582 t:2.571 p0:[6.015+/-0.873] p1:[0.184+/-0.031] dtime:3.777+/-1.988 t:2.571 p0:[7.521+/-1.068] p1:[0.160+/-0.031] dtime:4.346+/-2.723 t:2.571 p0:[9.560+/-1.271] p1:[0.127+/-0.030] dtime:5.437+/-4.366 t:2.571 p0:[12.437+/-1.209] p1:[0.083+/-0.024] dtime:8.380+/-8.572 t:2.571 p0:[13.303+/-1.859] p1:[0.114+/-0.032] dtime:6.059+/-6.167 t:2.571 p0:[13.057+/-1.824] p1:[0.160+/-0.031] dtime:4.335+/-2.653 t:2.571 p0:[14.418+/-1.593] p1:[0.173+/-0.024] dtime:4.015+/-1.667 t:2.571 p0:[17.087+/-1.654] p1:[0.165+/-0.021] dtime:4.194+/-1.585 t:2.571 p0:[21.314+/-2.297] p1:[0.138+/-0.024] dtime:5.012+/-2.747 t:2.571 p0:[26.925+/-2.907] p1:[0.101+/-0.025] dtime:6.858+/-5.948 t:2.571 p0:[34.197+/-1.535] p1:[0.059+/-0.011] dtime:11.673+/-7.019 t:2.571 p0:[37.553+/-1.153] p1:[0.053+/-0.008] dtime:13.053+/-5.754 t:2.571 p0:[39.323+/-1.584] p1:[0.062+/-0.010] dtime:11.207+/-5.600 t:2.571 p0:[41.082+/-1.595] p1:[0.069+/-0.010] dtime:10.069+/-4.193 t:2.571 p0:[42.095+/-1.228] p1:[0.083+/-0.007] dtime:8.374+/-2.010 t:2.571 p0:[45.229+/-1.262] p1:[0.081+/-0.007] dtime:8.552+/-2.005 t:2.571 p0:[50.618+/-2.094] p1:[0.066+/-0.010] dtime:10.564+/-5.042 t:2.571 p0:[57.048+/-2.110] p1:[0.046+/-0.009] dtime:15.136+/-10.153 . . Is social distancing slowing down the growth in COVID cases and hospitalizations? . Yes, in a big way. . Governor Newsom ordered Californians to stay at home on March 19th. We know that it takes about 1 week after infection for someone to feel sick, and about 2 weeks for them to get bad enough to need hospitalization according to this link. That means that new cases being reduced by the stay-at-home order wouldn&#39;t happen until after March 26th, and the first reduction in new hospitalizations about April 2nd. . See where the COVID hospitalization curve below starts to bend over to a shallower slope? A bit more than 2 wks after the stay at home order! The case curve doesn&#39;t bend a full week before that, but this is likely becuase we still had a huge backlog of tested people waiting for their results back then. . You can see this bending of the curve in the doubling time graphs in the last section of this notebook: For confirmed cases the first increases in doubling time are around March 29th. We see the first increases in hospitalization doubling time are on April 4th or so. In the last weeks of March the estimated doubling time was around 3 to 5 days for all metrics: cases, hospitalizations, ICU patients, and deaths. Today the doubling time for these is around 10 - 20 days. . You can see this curve bendingin the graph below. In March the growth rate of cases, hospitalizations, and deaths is steep and steady. In April things start to bend, and we have ended up with a steady, shallower rate of growth right now. . If there had been no stay at home order, then that late March doubling time would have continued until today. That would mean San Diego would have many times more infections than it currently does. The exact difference you can see below: . # this projection is based on doubling time calculated only over the last week of data daysfwd = 60 lcolors = colors[:2]+ colors[3:] fromdate = (pd.Timestamp(today)-pd.Timedelta(&#39;6 days&#39;)).isoformat().split(&#39;T&#39;)[0] startproj = (pd.Timestamp(today)+pd.Timedelta(&#39;1 day&#39;)).isoformat().split(&#39;T&#39;)[0] daystoproj = (pd.Timestamp(&#39;2020-03-19&#39;) + pd.Timedelta(&#39;{} days&#39;.format(daysfwd)) - pd.Timestamp(fromdate)).days print(&#39;Calculate exponential parameters on data from {} to {}, then project forward using those parameters for {} days&#39;.format(fromdate,today,daystoproj)) print(&#39;Compare with exponential parameters fit on data from 2020-03-19 to 2020-03-26&#39;) doubling_time, ci95, case_p_est, case_p_cov = estimate_doubling_time(cases[fromdate:]) doubling_time, ci95, orig_case_p_est, orig_case_p_cov = estimate_doubling_time(cases[&#39;2020-03-19&#39;:&#39;2020-03-26&#39;]) doubling_time, ci95, hosp_p_est, hosp_p_cov = estimate_doubling_time(hospitalizations[fromdate:]) doubling_time, ci95, orig_hosp_p_est, orig_hosp_p_cov = estimate_doubling_time(hospitalizations[&#39;2020-03-19&#39;:&#39;2020-03-26&#39;]) doubling_time, ci95, icu_p_est, icu_p_cov = estimate_doubling_time(icu[fromdate:]) doubling_time, ci95, death_p_est, death_p_cov = estimate_doubling_time(deaths[fromdate:]) doubling_time, ci95, orig_death_p_est, orig_death_p_cov = estimate_doubling_time(deaths[&#39;2020-03-19&#39;:&#39;2020-03-31&#39;]) projcases = pd.DataFrame(exfunc(range(0,daystoproj),case_p_est[0],case_p_est[1]), index=pd.date_range(start=fromdate,periods=daystoproj) ).astype(int) projhosp = pd.DataFrame(exfunc(range(0,daystoproj),hosp_p_est[0],hosp_p_est[1]), index=pd.date_range(start=fromdate,periods=daystoproj) ).astype(int) projdeath = pd.DataFrame(exfunc(range(0,daystoproj),death_p_est[0],death_p_est[1]), index=pd.date_range(start=fromdate,periods=daystoproj) ).astype(int) projcases.columns = [&#39;Cases projected today&#39;] projhosp.columns = [&#39;Hospitalized projected today&#39;] projdeath.columns = [&#39;Deaths projected today&#39;] projected = pd.merge( pd.merge(projcases, projhosp,left_index=True,right_index=True,how=&#39;outer&#39;), projdeath,left_index=True,right_index=True,how=&#39;outer&#39;) projected = projected[startproj:] orig_projcases = pd.DataFrame(exfunc(range(0,daysfwd),orig_case_p_est[0],orig_case_p_est[1]), index=pd.date_range(start=&#39;2020-03-19&#39;,periods=daysfwd) ).astype(int) orig_projhosp = pd.DataFrame(exfunc(range(0,daysfwd),orig_hosp_p_est[0],orig_hosp_p_est[1]), index=pd.date_range(start=&#39;2020-03-19&#39;,periods=daysfwd) ).astype(int) orig_projdeath = pd.DataFrame(exfunc(range(0,daysfwd),orig_death_p_est[0],orig_death_p_est[1]), index=pd.date_range(start=&#39;2020-03-19&#39;,periods=daysfwd) ).astype(int) orig_projcases.columns = [&#39;Cases projected on 2020-03-27&#39;] orig_projhosp.columns = [&#39;Hospitalized projected on 2020-03-27&#39;] orig_projdeath.columns = [&#39;Deaths projected on 2020-03-27&#39;] orig_projected = pd.merge(pd.merge(orig_projcases,orig_projhosp, left_index=True,right_index=True,how=&#39;outer&#39;), orig_projdeath,left_index=True,right_index=True,how=&#39;outer&#39;) orig_projected = orig_projected[&#39;2020-03-27&#39;:] actual = pd.merge( pd.merge(cases.rename(&#39;Confirmed cases history&#39;), hospitalizations.rename(&#39;Hospitalizations history&#39;), left_index=True,right_index=True,how=&#39;outer&#39; ), deaths.rename(&#39;Deaths history&#39;), left_index=True,right_index=True,how=&#39;outer&#39; ) actual.index = pd.DatetimeIndex(actual.index) fig, ax = plt.subplots(figsize=(10, 5)) projected.plot( title=(&#39;Without social distancing San Diego would have a much worse COVID-19 problem today n&#39; + &#39;Projections from March 27 hadn &#39;t yet shown the effects of social distancing and have steeper slopes than today &#39;s projections. n&#39; #&#39;Each projection is based on 1 week of data preceeding the date the projection is made&#39; ).format( actual.loc[today,&#39;Confirmed cases history&#39;], orig_projected.loc[today,&#39;Cases projected on 2020-03-27&#39;]) ,color=lcolors,ax=ax,logy=True,linestyle=&#39;--&#39;); orig_projected.plot(ax=ax,logy=True,color=lcolors,linestyle=&#39;-.&#39;,alpha=0.33) actual.plot(ax=ax,logy=True,color=lcolors,marker=&#39;.&#39;,linestyle=&#39;&#39;); lims = list(plt.ylim()) lims[1] = 2.0*10**5 plt.ylim(lims) print(&quot; n nIf we didn&#39;t social distance: nThe difference between 3/27 case projections and todays cases = {}&quot;.format( orig_projected.loc[today,&#39;Cases projected on 2020-03-27&#39;] - actual.loc[today,&#39;Confirmed cases history&#39;] )) print(&quot;The difference between 3/27 hospitalized projections and todays hospitalizations = {}&quot;.format( orig_projected.loc[today,&#39;Hospitalized projected on 2020-03-27&#39;] - actual.loc[today,&#39;Hospitalizations history&#39;] )) print(&quot;The difference between 3/27 deaths projections and todays deaths = {:1d}&quot;.format( orig_projected.loc[today,&#39;Deaths projected on 2020-03-27&#39;] - actual.loc[today,&#39;Deaths history&#39;] )) vals = orig_projected.loc[today].rename(&#39;Projected on 2020-03-27&#39;).to_frame() vals.index = [&#39;Cases&#39;, &#39;Hospitalized&#39;, &#39;Deaths&#39;] dos = actual.loc[today].rename(&#39;Today &#39;s actual numbers&#39;) dos.index = [&#39;Cases&#39;, &#39;Hospitalized&#39;, &#39;Deaths&#39;] vals = vals.join(dos) xmn = ax.get_xbound()[0] ax.annotate( vals.T.to_string(), xy=(0.4,0.07), xycoords=&#39;axes fraction&#39;, fontsize=10, family=&#39;monospace&#39;) plt.ylabel(&#39;Number of people&#39;); plt.legend(loc=&#39;upper left&#39;, ncol =3, fontsize=9)#, bbox_to_anchor=(0., .5, 1., 0.5)) plt.savefig(&#39;Plots/socialdistancing.png&#39;,dpi=300); . Calculate exponential parameters on data from 2020-04-14 to 2020-04-20, then project forward using those parameters for 34 days Compare with exponential parameters fit on data from 2020-03-19 to 2020-03-26 t:2.571 p0:[1952.489+/-11.098] p1:[0.030+/-0.001] dtime:22.914+/-3.061 t:2.447 p0:[117.793+/-5.873] p1:[0.153+/-0.009] dtime:4.522+/-0.716 t:2.571 p0:[466.366+/-6.671] p1:[0.034+/-0.004] dtime:20.567+/-6.597 t:2.447 p0:[20.756+/-2.468] p1:[0.171+/-0.022] dtime:4.058+/-1.453 t:2.571 p0:[168.902+/-2.399] p1:[0.022+/-0.004] dtime:31.950+/-17.377 t:2.571 p0:[57.048+/-2.110] p1:[0.046+/-0.009] dtime:15.136+/-10.153 t:2.201 p0:[0.679+/-0.197] p1:[0.222+/-0.028] dtime:3.127+/-0.984 If we didn&#39;t social distance: The difference between 3/27 case projections and todays cases = 13566 The difference between 3/27 hospitalized projections and todays hospitalizations = 4345 The difference between 3/27 deaths projections and todays deaths = 745 . Let me help you understand the graph: I used SD County&#39;s own counts of COVID-19 patients. The two prediction lines are made by fitting exponential parameters to the number of people hospitalized with COVID19 from March 19 - 26 and to hospitalizations in the last week. Note that these graphs have a y-axis which is logarithmic: it goes up 10, 100, 1000, 10000, etc... . In the early stages of an epidemic, the numbers grow exponentially: 1 becomes 2 becomes 4, becomes 8, 16, 32, etc. In 10 steps there&#39;s &gt;1,000. In 20 steps its &gt; 1,000,000. Something that has this kind of exponential growth curve on a linear plot becomes a straight line on a plot with a logarithmic y-axis. . And you can see in this plot that there are essentially two &quot;straight lines&quot; in each metric being tracked. Things have a steeper sloped line in March, and a gentler slope for the line in April. That shows you that we were on track to have a much worse outbreak in March, but something changed. . And as I said above, the thing that changed was the social distancing and various shutdowns. And the timing of the change, being almost exactly 2 weeks afterwards, suggests that the stay at home orders and shutdowns are the major reason for the good news. . I will note one caveat about the death projections above. Back in mid March we didn&#39;t have enough death data to get a really good estimate of the growth rate by 3/26. In fact, the death data projection includes data through all of March to get the slope to try to get a better estimate. Because of this trouble, you could also consider an alternate method for projecting deaths: Just take. the current death rate of people in the hospital for OCVID-19 (about 12%) and multiply it by the projected hospitalizations from March 26th. This yields a slighly less bad projection on COVID-19 deaths today: . print(&#39;Alternate prediction of dead COVID-19 patients today if we had not been social distancing:&#39;) print(&#39;{:d}&#39;.format(int( orig_projhosp.loc[today] * frac[&#39;Deaths&#39;].iloc[-1]))) . Alternate prediction of dead COVID-19 patients today if we had not been social distancing: 628 . But that number is still bad, and most importantly, as soon as we have more patients in hospital with COVID-19 then we can reasonably treat then the percentage of people who will die from this disease is going to go up quickly. Which is what I&#39;ll address in teh next section... . The number of available hospital beds . &quot;As of 2018, San Diego had 6,180 total hospital beds. Of those, about 68% were occupied at any given time. That leaves 1,950 beds, including 800 intensive care unit beds, available for new patients.&quot; - https://www.kpbs.org/news/2020/mar/20/data-suggests-san-diego-hospitals-will-be-overfill/ . Update: In early April the federal government started the process to add 250 beds to the unused upper floors of Palomar Hosptial. Also in the weeks since the article above, all hospitals have been postponing elective procedures and generally doing what they can to free up beds. You would also expect a lower rate of accidents with the reductions in work and traffic. . I do not have any sources to describe the current number of free beds in San Diego county but I expect it is 100s if not 1000s more than it was when the March 20th article was written. Things that have happened to increase bed capacity: . Hospitals have tried to reduce utilization by cancelling elective procedures | 250 beds are being added to Palomar Hospital on the upper floors in the next weeks | UCSD has designated an unknown number of beds in their dorms as an alternate site to host recovering COVID patients to free up beds for the people just beginning to get sick | . All this will lead me to make two different hospital capacity predictions: . an optimistic one that assumes federal hospitals will help (like Navy), a huge increase in free beds based on going from 50% free beds to 70% free beds, and 500 additional beds from Palomar and UCSD. | a pessimistic one based soley on free SD county beds from March 20th | . # Pessimistic number of county only (ignores federal) beds/icu beds available on March 20th from kpbs article above availbeds = 1950 availicu = 800 # optimistic bed capacity based on # 1) all beds including federal beds in navy hospitals (https://www.sandiegouniontribune.com/news/health/story/2020-03-16/regions-hospitals-could-face-thousands-of) # 2) reduce hospital utilization from 50% to 30% by cancelling procedures # 3) increase of 250 beds from palomar hospital expansion # 3) add 250 beds from UCSD alternate care site (WAG from me. There is no statement on how many beds this would be) availbedsO = int(8614*.7 + 500) print(&#39;pessimistic estimate of capacity: 1850 noptimistic estimate of capacity: {}&#39;.format(availbedsO)) . pessimistic estimate of capacity: 1850 optimistic estimate of capacity: 6529 . # this projection is based on doubling time calculated only over the last week of data daysfwd = 90 fromdate = (pd.Timestamp(today)-pd.Timedelta(&#39;6 days&#39;)).isoformat().split(&#39;T&#39;)[0] startproj = (pd.Timestamp(today)+pd.Timedelta(&#39;1 day&#39;)).isoformat().split(&#39;T&#39;)[0] daystoproj = (pd.Timestamp(&#39;2020-03-19&#39;) + pd.Timedelta(&#39;{} days&#39;.format(daysfwd)) - pd.Timestamp(fromdate)).days print(&#39;Calculate exponential parameters on data from {} to {}, then project forward using those parameters for {} days&#39;.format(fromdate,today,daystoproj)) doubling_time, ci95, case_p_est, case_p_cov = estimate_doubling_time(cases[fromdate:]) doubling_time, ci95, orig_case_p_est, orig_case_p_cov = estimate_doubling_time(cases[&#39;2020-03-19&#39;:&#39;2020-03-26&#39;]) doubling_time, ci95, hosp_p_est, hosp_p_cov = estimate_doubling_time(hospitalizations[fromdate:]) doubling_time, ci95, orig_hosp_p_est, orig_hosp_p_cov = estimate_doubling_time(hospitalizations[&#39;2020-03-19&#39;:&#39;2020-03-26&#39;]) doubling_time, ci95, icu_p_est, icu_p_cov = estimate_doubling_time(icu[fromdate:]) hospital_capacity = days_to_value(hosp_p_est,availbeds) hospital_capacityO = days_to_value(hosp_p_est,availbedsO) orig_hospital_capacity = days_to_value(orig_hosp_p_est,availbeds) orig_hospital_capacityO = days_to_value(orig_hosp_p_est,availbedsO) print(&#39;Before social distancing had enough time to work, hospitals were projected to reach capacity on {}&#39;.format(pd.Timestamp(&#39;2020-03-20&#39;) + pd.Timedelta(&#39;1 day&#39;)*orig_hospital_capacity)) print(&#39;Now I think hospitals reach capacity on {}&#39;.format(pd.Timestamp(fromdate) + pd.Timedelta(&#39;1 day&#39;)*hospital_capacity)) print(&#39;Or optimistically they reach capacity on {}&#39;.format(pd.Timestamp(fromdate) + pd.Timedelta(&#39;1 day&#39;)*hospital_capacityO)) icu_capacity = days_to_value(icu_p_est, availicu) print(&#39;ICUs reach capacity on {}&#39;.format(pd.Timestamp(fromdate) + pd.Timedelta(&#39;1 day&#39;)*icu_capacity)) projhosp = pd.DataFrame(exfunc(range(0,daystoproj),hosp_p_est[0],hosp_p_est[1]), index=pd.date_range(start=fromdate,periods=daystoproj) ).astype(int) projhosp.columns = [&#39;Hospitalized projected from today&#39;] projected = projhosp[startproj:] orig_projhosp = pd.DataFrame(exfunc(range(0,daysfwd),orig_hosp_p_est[0],orig_hosp_p_est[1]), index=pd.date_range(start=&#39;2020-03-19&#39;,periods=daysfwd) ).astype(int) orig_projhosp.columns = [&#39;Hospitalized projected on 2020-03-27&#39;] orig_projected = orig_projhosp[&#39;2020-03-27&#39;:] actual = hospitalizations.rename(&#39;History of hospitalizations&#39;) actual.index = pd.DatetimeIndex(actual.index) fig, ax = plt.subplots(figsize=(10, 5)) projected.plot( title=(&#39;Social distancing has shifted the date we could run out of hospital beds backwards by at least a month n&#39;+ &#39;Projections from March 27 hadn &#39;t yet shown the effects of social distancing and have steeper slopes than today &#39;s projections. n&#39; + &#39;Each projection is based on 1 week of data preceeding the date the projection is made&#39; ) ,ax=ax,logy=True,linestyle=&#39;--&#39;,color=colors[1]); orig_projected.plot(ax=ax,logy=True,color=colors[4],linestyle=&#39;-.&#39;,alpha=0.4) actual.plot(ax=ax,logy=True,color=colors[1],marker=&#39;.&#39;,linestyle=&#39;&#39;); ts1 = pd.Timestamp(fromdate) + pd.Timedelta(&#39;1 day&#39;)*hospital_capacity ts2 = pd.Timestamp(fromdate) + pd.Timedelta(&#39;1 day&#39;)*hospital_capacityO plt.ylabel(&#39;Number of people&#39;); shiftvline = (pd.Timestamp(fromdate) - pd.Timestamp(&#39;2020-03-19&#39;)).days xmn = ax.get_xbound()[0] xmx = (hospital_capacity + xmn + shiftvline) ymn = 0 ymx = availbeds ax.plot([xmn, xmx], [ymx,ymx], linestyle=&#39;:&#39;, color=&#39;k&#39;, alpha=0.5); ax.plot([xmx, xmx], [ymn,ymx], linestyle=&#39;:&#39;, color=&#39;k&#39;, alpha=0.5); ax.annotate(&#39;Pessimistic hospital capacity&#39;, xy=(xmn+1, 2300), xycoords=&#39;data&#39;, fontsize=10); # original capacity date xmx = orig_hospital_capacity + xmn ax.plot([xmx, xmx], [ymn,ymx], linestyle=&#39;:&#39;, color=&#39;k&#39;, alpha=0.5); ax.annotate(&#39;Prediction made before nsocial distancing took effect nApril 15 - April 22&#39;, xy=(xmx-4, 10), xycoords=&#39;data&#39;, fontsize=10); xmn = ax.get_xbound()[0] xmx = (hospital_capacityO + xmn + shiftvline) ymn = 0 ymx = availbedsO ax.plot([xmn, xmx], [ymx,ymx], linestyle=&#39;:&#39;, color=&#39;k&#39;, alpha=0.5); ax.plot([xmx, xmx], [ymn,ymx], linestyle=&#39;:&#39;, color=&#39;k&#39;, alpha=0.5); ax.annotate(&#39;Optimistic hospital capacity&#39;, xy=(xmn+1, 7200), xycoords=&#39;data&#39;, fontsize=10); ax.annotate(&#39;Current prediction n{} - {}&#39;.format(ts1.strftime(&#39;%B %e&#39;), ts2.strftime(&#39;%B %e&#39;)), xy=(xmx-30, 10), xycoords=&#39;data&#39;, fontsize=10); # original capacity date xmx = orig_hospital_capacityO + xmn ax.plot([xmx, xmx], [ymn,ymx], linestyle=&#39;:&#39;, color=&#39;k&#39;, alpha=0.5); lims = list(plt.ylim()) lims[1] = 2.0*10**5 plt.ylim(lims) plt.legend(loc=&#39;best&#39;)#, bbox_to_anchor=(0., .5, 1., 0.5)) plt.savefig(&#39;Plots/hospitalcapacity-compare.png&#39;,dpi=300); . Calculate exponential parameters on data from 2020-04-14 to 2020-04-20, then project forward using those parameters for 64 days t:2.571 p0:[1952.489+/-11.098] p1:[0.030+/-0.001] dtime:22.914+/-3.061 t:2.447 p0:[117.793+/-5.873] p1:[0.153+/-0.009] dtime:4.522+/-0.716 t:2.571 p0:[466.366+/-6.671] p1:[0.034+/-0.004] dtime:20.567+/-6.597 t:2.447 p0:[20.756+/-2.468] p1:[0.171+/-0.022] dtime:4.058+/-1.453 t:2.571 p0:[168.902+/-2.399] p1:[0.022+/-0.004] dtime:31.950+/-17.377 Before social distancing had enough time to work, hospitals were projected to reach capacity on 2020-04-15 14:19:38.844414724 Now I think hospitals reach capacity on 2020-05-26 10:45:20.696810614 Or optimistically they reach capacity on 2020-07-01 07:17:15.998446332 ICUs reach capacity on 2020-06-24 16:32:06.430344295 . When there are more patients than beds, people die more often than if there was good care available (see wha&#39;s happened in NYC and northern Italy). On March 20th KPBS said there were about 1850 available hospital beds for COVID19 patients Probably there are several hundred or maybe a couple of thousand more by now. People aren&#39;t doing elective hospital procedures anymore, and there are at least 250 new beds added to the system as I outlined above. . But assume for a minute that 1850 were all the beds there were. And assume social distancing didn&#39;t happen. Then today we be out of beds and San Diego hospitals would be in crisis... take a look at the graph above... that 1850 number is the pessimistic hospital capacity line. You can see that if we followed the same path we were on in early March, today we would have many more people in hospital than there were available beds. The current situation might be like in hard hit parts of NYC: patients lying in the hallways, left largely unattended because there aren&#39;t enough people to care for them. . Now what about the path we are now? The doubling time of hospitlaization is much slower right now, but it&#39;s still not flat. But we have flattened the curve, and bought ourselves enough time to add hospital capacity so we can avoid a NYC situation. When the projections are flat, horizontal lines then we will be able to breathe a sigh of relief. That&#39;s the point at which its safe to relax the stay at home orders and social distancing in small steps. . And yet even then we must be careful. It is clear that the disease could come roaring back into our region again. We must be vigilant, and ready to put into place some control measures once again if necessary. . N.B. My hospital capacity estimates might be optimistic. . I ran my estimates by two people who actually know stuff. . My summary: Hospitals could be stressed and not dealing well with the infected as soon as they have a couple of patients. They will then adjust and just make-do as best they can, shutting down services, moving resources from here to there as much as they can. These decisions will be made differently by each hospital so there&#39;s really no way to predict hospital capacity. . Perhaps you can see my capacity limit estimate as an upper limit... that is the hospital system in San Diego will likely be in crisis well before my estimate of late May (NB: originally this was mid April, but doubling time is slowing dramatically now!) . To read the actual exchange, which took place on March 26th, see below . --Jason . Gerald Pao, an MD/PhD who&#39;s worked in virology... . Although this is a reasonable estimate at face value it does not take into account how a hospital works You cannot have the highly contagious population in the same space as the rest of the patients who are there for other reasons. So you need to ask how many barrier nursing negative pressure beds does the hospital have? The answer is for any normal hospital the number of beds is between 5-10 I have asked my friends in CA from the Bay area, LA and SD and no one has given me a number higher than 10 This means people will have to designate hospital wings to this task and somehow separate things. In places in Spain and Italy they sometimes designated particular hospitals for this task or had the ER designated for it and rearranged it. In other ones they had particular floors closed off etc. so the real capacity will depend on what the hospital administrators decide to do and will be made in uneven and unpredictable ways as there is no single set of rules on how to manage this. Therefore the pressure on hospitals and when you will be out of capacity will be difficult to estimate. We do not have a national healthcare system as you know so it’s gonna be a a free for all. . Gerald Pao . The Salk Institute for Biological Studies . Joel Wertheim, a bioinformatician who specializes in the evolution and epidemiology of HIV... . Hi Jason, . Interesting stuff. . Another point to consider in the general design is the time-lag between all of these states. Most people are not admitted to the hospital for quite some time after infection. If they proceed to the ICU and/or death, that also can take weeks after initial infection/diagnosis. I’m not sure of the proportion of cases in San Diego diagnosed after admittance to the hospital, as opposed to be people who aren&#39;t (yet) sick enough to be hospitalized. . Also, at UC San Diego, negative pressure rooms were originally used for COVID patients (back when we were treating the first patients brought back from China). Now, they are just being used for procedures that would result in high likelihood of spread (i.e., intubation). So the number of beds can change with the severity of the epidemic (as Gerald also mentioned). . Cheers, . Joel . University of California San Diego . Below this is just some stuff I started to scrape the location data... . But TBH I now think this is useless... there&#39;s no way the location of infection is useful except as a proxy for which hospitals are most burdened. . Certainly you wouldn&#39;t want to say something like &quot;Oh this is were you can catch the virus the best...&quot; That&#39;s some BS because there is 1) unknown infected people out there and 2) the location is someone&#39;s DMV/voting record of residence, not necessarily where they actually live, hang out, shop, and work. . # these column locations are hand tuned locations = read_pdf(&#39;https://www.sandiegocounty.gov/content/dam/sdc/hhsa/programs/phs/Epidemiology/COVID-19%20Daily%20Update_City%20of%20Residence.pdf&#39;, options=&quot;--columns 250.0,375.0&quot;, guess=False) . # because I&#39;m not parsing the date out of the pdf, you should manually make sure this has been updated too before scraping! # 3/25 version &#39;&#39;&#39;locations = locations.set_index(&#39;County of San Diego&#39;) locations = locations[&#39;San Diego County&#39;:&#39;OVERALL TOTAL&#39;].dropna() locations.columns = locations.loc[&#39;San Diego County&#39;,:] locations = locations.drop(&#39;San Diego County&#39;) locations.to_csv(locf.format(today)) print(today) locations&#39;&#39;&#39; None; . # because I&#39;m not parsing the date out of the pdf, you should manually make sure this has been updated too before scraping! # 3/26 version locations = locations.set_index(&#39;County of San Diego&#39;) locations = locations[&#39;San Diego County&#39;:&#39;Total San Diego County Residents&#39;].dropna() locations.columns = locations.loc[&#39;San Diego County&#39;,:] locations = locations.drop(&#39;San Diego County&#39;) locations.to_csv(locf.format(today)) print(today) locations . 2020-04-20 . San Diego County Count Percentage** of Overall Total . County of San Diego . Incorporated City | 2,004 | 86.2% | . Carlsbad | 50 | 2.2% | . Chula Vista | 258 | 11.1% | . Coronado | 7 | 0.3% | . Del Mar | 11 | 0.5% | . El Cajon | 132 | 5.7% | . Encinitas | 34 | 1.5% | . Escondido | 71 | 3.1% | . Imperial Beach | 14 | 0.6% | . La Mesa | 49 | 2.1% | . Lemon Grove | 19 | 0.8% | . National City | 66 | 2.8% | . Oceanside | 53 | 2.3% | . Poway | 21 | 0.9% | . San Diego | 1,127 | 48.5% | . San Marcos | 27 | 1.2% | . Santee | 24 | 1.0% | . Solana Beach | 6 | 0.3% | . Vista | 35 | 1.5% | . Unincorporated | 300 | 12.9% | . Alpine | 2 | 0.1% | . Bonita | 15 | 0.6% | . Bonsall | 1 | 0.0% | . Borrego Springs | 1 | 0.0% | . Boulevard | 2 | 0.1% | . Campo | 0 | 0.0% | . Descanso | 1 | 0.0% | . Fallbrook | 11 | 0.5% | . Jamul | 6 | 0.3% | . Julian | 2 | 0.1% | . Lakeside | 18 | 0.8% | . Pauma Valley | 2 | 0.1% | . Potrero | 2 | 0.1% | . Ramona | 12 | 0.5% | . Ranchita | 2 | 0.1% | . Rancho Santa Fe | 14 | 0.6% | . Spring Valley | 61 | 2.6% | . Valley Center | 4 | 0.2% | . Other | 144 | 6.2% | . Unknown* | 21 | 0.9% | . Total San Diego County Residents | 2,325 | 100.0% | . zips = read_pdf(&#39;https://www.sandiegocounty.gov/content/dam/sdc/hhsa/programs/phs/Epidemiology/COVID-19%20Summary%20of%20Cases%20by%20Zip%20Code.pdf&#39;) . # on 4/3 the column read changed a bit, had been .iloc[1,:], now its [0,:] # on 4/5 its back to .iloc[1,:] # on 4/7 its back to [0,:] zips.columns = zips.iloc[1,:] zips = zips[2:] zips = pd.concat([zips.iloc[:,:2], zips.iloc[:,2:]]).set_index(&#39;Zip Code&#39;).dropna() zips.to_csv(zipf.format(today)) print(today) zips . 2020-04-20 . 1 Count . Zip Code . 91901 | 2 | . 91902 | 18 | . 91905 | 2 | . 91910 | 70 | . 91911 | 98 | . ... | ... | . 92154 | 107 | . 92161 | 1 | . 92173 | 59 | . Unknown | 31 | . Total | 2325 | . 95 rows × 1 columns .",
            "url": "https://jasongfleischer.github.io/argo-navis/covid19/jupyter/epidemiology/2020/04/20/SanDiego-COVID-19.html",
            "relUrl": "/covid19/jupyter/epidemiology/2020/04/20/SanDiego-COVID-19.html",
            "date": " • Apr 20, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Buzz Aldrin's lifetime mean altitude",
            "content": "At some point online I saw someone calculate Neil Armstrong&#39;s mean lifetime altitude. This seems like a complete Randall Monroe of xkcd.com kind of thing. But I cannot for the life of me find the link now to put it here. . Anyway I needed a silly toy problem to test the Jupyter notebook to blog post capability of fastpages now that I&#39;m using it. So here I am... extending the Armstrong problem to the case of a still-alive astronaut who&#39;s lifetime mean altitude is slowly decreasing. . # per wiki he graduated USMA in 1951 and by 1972 at retirement. I made up the graduation date # he already had 3500 hours flying time per https://www.nationalaviation.org/our-enshrinees/aldrin-buzz/ # assume 9km average flight altitude (~30kft) AFstart = pd.Timestamp(&#39;May 1, 1951 12:00:00 UTC&#39;) AFend = pd.Timestamp(&#39;July 1, 1971 12:00:00 UTC&#39;) AFdur = AFend - AFstart AFeffectiveAlt = 9 * pd.Timedelta(&#39;3500 hours&#39;) / AFdur # spread flight hours over the whole AF career evenly # Gemini 12 https://en.wikipedia.org/wiki/Gemini_12 # assume mean orbital distance of apogee and perigee G12start = pd.Timestamp(&#39;November 11, 1966, 20:46:33 UTC&#39;) G12end = pd.Timestamp(&#39;November 15, 1966, 19:21:04 UTC&#39;) G12meanAlt = np.mean([160,270]) # already in km from wiki # Apollo 11 https://airandspace.si.edu/sites/default/files/images/5317h.jpg # https://history.nasa.gov/SP-4029.pdf # Table 7.11 of https://www.hq.nasa.gov/alsj/a11/a11MIssionReport_1971015566.pdf MoonMeanDistKm = 384400 A11liftoff = pd.Timestamp(&#39;July 16, 1969, 13:32:00 UTC&#39;) A11EarthOrbitAlt = 100 * NMi2Km # this is rough A11TLI = A11liftoff + pd.Timedelta(&#39;2 hours 50 minutes&#39;) A11MidcourseOut = A11liftoff + pd.Timedelta(&#39;26 hours 45 minutes&#39;) A11MidcourseAlt = 109475 * NMi2Km A11LunarInsert = A11liftoff + pd.Timedelta(&#39;75 hours 50 minutes&#39;) A11TEI = A11liftoff + pd.Timedelta(&#39;135 hours 24 minutes&#39;) A11splashdown = A11liftoff + pd.Timedelta(&#39;195 hours 18 minutes&#39;) # lets check to see if we need to do any detailed interpolation, or if mean is enough... # print(109475 * NMi2Km / MoonMeanDistKm, (A11MidcourseOut - A11TLI) / (A11LunarInsert - A11MidcourseOut)) # &gt; 0.5274393860561915 0.4872665534804754 # this is close enough to linear interpolation that I&#39;m not going to bother with anything else # so for the duration of the flight from earth to moon, just fill in 1/2 the lunar distance baidx = pd.date_range(start=&#39;January 20, 1930&#39;,end=&#39;January 20, 2020&#39;,freq=&#39;H&#39;) BuzzAlt = pd.Series(0,index=baidx) BuzzAlt[AFstart:AFend] = AFeffectiveAlt BuzzAlt[G12start:G12end] = G12meanAlt BuzzAlt[A11liftoff:A11TLI] = A11EarthOrbitAlt BuzzAlt[A11TLI:A11LunarInsert] = MoonMeanDistKm / 2 BuzzAlt[A11LunarInsert:A11TEI] = MoonMeanDistKm BuzzAlt[A11TEI:A11splashdown] = MoonMeanDistKm / 2 . BuzzAlt.plot(logy=True, ylim=(1,1000000)); plt.ylabel(&#39;kilometers&#39;); plt.xlabel(&#39;on this date&#39;); plt.title(&#39;Aldrin &#39;s altitude history&#39;); plt.annotate(&#39;Gemini 12&#39;, xy=(G12start,2*10**2), xycoords=&#39;data&#39;, xytext=(-55,0), textcoords=&#39;offset points&#39;); plt.annotate(&#39;Apollo 11&#39;, xy=(A11liftoff,4*10**5), xycoords=&#39;data&#39;, xytext=(5,0), textcoords=&#39;offset points&#39;); . BuzzAlt.expanding().mean().plot(logy=True,ylim=(0.0001,1000)); plt.ylabel(&#39;kilometers&#39;); plt.xlabel(&#39;as of this date&#39;); plt.title(&#39;Aldrin &#39;s mean altitude over his lifetime at a given time&#39;); plt.annotate(&#39;Gemini 12&#39;, xy=(G12start,10**-1), xycoords=&#39;data&#39;, xytext=(-55,0), textcoords=&#39;offset points&#39;); plt.annotate(&#39;Apollo 11&#39;, xy=(A11liftoff,10**2), xycoords=&#39;data&#39;, xytext=(-50,0), textcoords=&#39;offset points&#39;); plt.annotate(&#39;Air Force nflight hours&#39;, xy=(AFstart,10**-2), xycoords=&#39;data&#39;, xytext=(-60,-10), textcoords=&#39;offset points&#39;); . # same thing, but linear y-axis instead of log BuzzAlt.expanding().mean().plot(); plt.ylabel(&#39;kilometers&#39;); plt.xlabel(&#39;as of this date&#39;); plt.title(&#39;Aldrin &#39;s mean altitude over his lifetime at a given time&#39;); plt.annotate(&#39;Gemini 12&#39;, xy=(G12start,10**-1), xycoords=&#39;data&#39;, xytext=(-55,10), textcoords=&#39;offset points&#39;); plt.annotate(&#39;Apollo 11&#39;, xy=(A11liftoff,10**2), xycoords=&#39;data&#39;, xytext=(-50,10), textcoords=&#39;offset points&#39;); plt.annotate(&#39;Air Force nflight hours&#39;, xy=(AFstart,10**-2), xycoords=&#39;data&#39;, xytext=(-60,10), textcoords=&#39;offset points&#39;); .",
            "url": "https://jasongfleischer.github.io/argo-navis/funny/jupyter/xkcd/2020/02/29/Buzz-Aldrin's-average-altitude.html",
            "relUrl": "/funny/jupyter/xkcd/2020/02/29/Buzz-Aldrin's-average-altitude.html",
            "date": " • Feb 29, 2020"
        }
        
    
  

  
  

  

  
      ,"page2": {
          "title": "Publications",
          "content": "L Chow, ENC Manoogian, A Alvear, JG Fleischer, H Thor, K Dietsche, Q Wang, JS Hodges, KS Nair, S Panda, DG Mashek. (In press) Effects of time restricted eating on body composition and metabolic measures in overweight humans: a randomized trial. Obesity. | MJ Wilkinson, ENC Manoogian, A Zadourian, H Loa, S Fakourib, A Shoghib, JG Fleischer, S Navlakha, S Panda, PR Taub. (2019) Ten-hour time-restricted eating reduces weight, blood pressure, and atherogenic lipids in patients with metabolic syndrome. Cell Metabolism,31(1):92-104, https://doi.org/10.1016/j.cmet.2019.11.004 | AT Hutchison, P Regmi, ENC Manoogian, JG Fleischer, GA Wittert, S Panda, LK Heilbronn. (2019) Time-restricted feeding improves glucose tolerance in men at risk of type 2 diabetes: a randomized crossover trial. Obesity https://doi.org/10.1002/oby.22449 | JG Fleischer, R Schulte, HH Tsai, S Tyagi, A Ibarra, MN Shokhirev, L Huang, MW Hetzer, S Navlakha (2018). Predicting age from the transcriptome of human dermal fibroblasts. Genome Biology, 19:221. https://doi.org/10.1186/s13059-018-1599-6 | GP Dunster, L de la Iglesia, M Ben-Hamo, C Nave, JG Fleischer, S Panda, HO de la Iglesia (2018). Sleepmore in Seattle: Later school start times are associated with more sleep and better performance in high school students. Science Advances, 4 (12), eaau6200. https://dx.doi.org/10.1126/sciadv.aau6200 | JL McKinstry, JG Fleischer, Y Chen, WE Gall, GM Edelman (2016). Imagery may arise from associations formed through sensory experience: a network of spiking neurons controlling a robot learns visual sequences in order to perform a mental rotation task. PLOS One, https://dx.doi.org/10.1371/journal.pone.0162155 | JG Fleischer (2014). Persistent activity through multiple mechanisms in a spiking network that solves DMS tasks. Computational and Systems Neuroscience Meeting (COSYNE). | JG Fleischer and JA Gally (2013). A spiking neural network model of working memory can solve delayed match-to-sample tasks and displays a serial position effect. Poster at The Society for Neuroscience Annual Meeting. | JG Fleischer and AE Kozarev (2012). Perceptual grouping and figure-ground segre- gation arising from short-term plasticity in a spiking network. Computational and Systems Neuroscience Meeting (COSYNE) . | JG Fleischer, JL McKinstry, DE Edelman, and GM Edelman (2011). The Case For Using Brain-Based Devices To Study Consciousness. In, JL Krichmar and H Wagatsuma (Eds.), Neuromorphic and Brain-Based Robots: Trends and Perspectives, Cambridge University Press, pp. 303–320. | JG Fleischer and GM Edelman (2009). Brain-based devices: An embodied approach to linking nervous system structure and function to behavior. IEEE Robotics &amp; Automation Magazine, 16(3):33–41. https://dx.doi.org/10.1109/MRA.2009.933621 | JG Fleischer and JL Krichmar (2007). Sensory integration and remapping in a medial temporal lobe model during maze navigation by a brain-based device. Journal of Integrative Neuroscience, 6(3):403–431. http://dx.doi.org/10.1142/S0219635207001568 | JG Fleischer, JA Gally, GM Edelman, and JL Krichmar (2007). Retrospective and prospective responses arising in a modeled hippocampus during maze navigation by a brain-based device. Proceedings of the National Academy of Sciences USA, 104(9):3556–3561. https://doi.org/10.1073/pnas.0611571104 | DA Nitz, WJ Kargo, and JG Fleischer (2007). Dopamine signaling and the distal reward problem. Neuroreport, 18(17):1833–1836. https://doi.org/10.1097/WNR.0b013e3282f16d86 | JG Fleischer (2007). Neural correlates of anticipation in cerebellum, basal ganglia, and hippocampus. In, MV Butz, O Siguard, G Baldassarre, G Pezzulo (Eds.),, Anticipatory Behavior in Adaptive Learning Systems: From Brains to Individual and Social Behavior, Lecture Notes in Artificial Intelligence. vol 4520, pp.19–34. | JG Fleischer, JA Gally, GM Edelman, and JL Krichmar (2007). Different neural pathways lead to journey-dependent and journey-independent place cell activity in an embodied model of hippocampus. Poster at The Society for Neuroscience Annual Meeting. | JG Fleischer, B Szatmary, DB Hutson, DA Moore, JA Snook, GM Edelman, and JL Krichmar (2006). A neurally controlled robot competes and cooperates with humans in Segway Soccer. In Proceedings of the IEEE International Conference on Robotics and Automation, pp.3673–3678 | B Szatmary, JG Fleischer, DB Hutson, DA Moore, JA Snook, GM Edelman, and JL Krichmar (2006). A Segway-based human-robot soccer team. In Proceedings of the IEEE International Conference on Robotics and Automation, pp.4436–4438. | JL Krichmar, AK Seth, DA Nitz, JG Fleischer, and GM Edelman (2005). Spatial navigation and causal analysis in a brain-based device modeling cortical-hippocampal interactions. Neuroinformatics, 3(3):197–222. https://doi.org/10.1385/NI:3:3:197 | JG Fleischer (2004). Imitation is not enough for lexicon learning In Proceedings of the Eighth International Conference on Simulation of Adaptive Behavior, pp.477– 486. | JG Fleischer, SR Marsland, and JL Shapiro (2003). Sensory Anticipation for Autonomous Selection of Robot Landmarks. In, MV Butz, O Siguard, P Gerard (Eds.), Anticipatory Behavior in Adaptive Learning Systems: Foundations, Theories, and Systems, Lecture Notes in Artificial Intelligence. vol 2684, pp.201–221. | JG Fleischer and SR Marsland (2002). Learning to autonomously select landmarks for navigation and communication. In Proceedings of the Seventh International Conference on Simulation of Adaptive Behavior, pp. 151–160. | JG Fleischer and UDF Nehmzow (2001). Towards robots that give each other navigational directions: Learning symbols for perceptual categories. In Proceedings of the 3rd British Conference on Autonomous Mobile Robotics and Autonomous Systems. Dept. of Computer Science, University of Manchester Technical Report UMCS-01-4-1. | JG Fleischer and WO Troxell (1999). Biomimicry as a tool in the design of robotic systems. In Proceedings of the 3rd International Conference on Engineering Design and Automation. Integrated Technology Systems, Prospect, KY. | .",
          "url": "https://jasongfleischer.github.io/argo-navis/publications/",
          "relUrl": "/publications/",
          "date": ""
      }
      
  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://jasongfleischer.github.io/argo-navis/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}